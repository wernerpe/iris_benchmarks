import os
import collada
import numpy as np 
from get_AABB import get_AABB_cvxhull

collision_geoms = {}
def rpy_to_matrix(vec):
    roll = vec[0]
    pitch = vec[1]
    yaw = vec[2]
    R_x = np.array([[1, 0, 0],
                    [0, np.cos(roll), -np.sin(roll)],
                    [0, np.sin(roll), np.cos(roll)]])

    R_y = np.array([[np.cos(pitch), 0, np.sin(pitch)],
                    [0, 1, 0],
                    [-np.sin(pitch), 0, np.cos(pitch)]])

    R_z = np.array([[np.cos(yaw), -np.sin(yaw), 0],
                    [np.sin(yaw), np.cos(yaw), 0],
                    [0, 0, 1]])

    R = np.dot(R_z, np.dot(R_y, R_x))
    return R

def convert_dae_to_obj(dae_file_path, obj_file_path, scaling = 1):
    try:
        # Load Collada file
        collada_scene = collada.Collada(filename=dae_file_path)
        with open(dae_file_path, 'r') as f:
            for l in f:
                if '<unit meter="0.001" name="Millimeters" />' in l:
                    scaling = 0.001
                 
        vertex_lines = []
        vertices = []
        face_lines = []
        # Open OBJ file for writing
        with open(obj_file_path, 'w') as obj_file:
            # Write vertices
            num_vertices = 0
            for geometry in collada_scene.geometries:
                for primitive in geometry.primitives:
                    for vertex in primitive.vertex:
                        vertex_lines.append(f"v {scaling*vertex[0]:.6f} {scaling*vertex[1]:.6f} {scaling*vertex[2]:.6f}\n")
                        vertices.append(scaling*np.array([vertex[0], vertex[1], vertex[2]]))
                        num_vertices+=1
            # # 28482 vertices, 0 vertices normals
            # obj_file.write(f"{num_vertices} vertices, 0 vertices normals\n")
            # obj_file.write("\n")
            
            # Write faces
            current_vertex_index = 1
            for geometry in collada_scene.geometries:
                for primitive in geometry.primitives:
                    for face in primitive.vertex_index:
                        string = "f"
                        for index in face:
                            assert index + current_vertex_index<= num_vertices
                            string += f" {index + current_vertex_index}"
                            face_lines.append(string + "\n")
                    current_vertex_index += len(primitive.vertex) 

            header = ['####',
                        '#',
                        '# OBJ File Generated by Meshlab',
                        '#',
                        '####',
                        '# Object link_0.obj',
                        '#',
                        f"# Vertices: {num_vertices}",
                        f"# Faces: {len(face_lines)}",
                        '#',
                        '####']
            for l in header:
                obj_file.write(l+"\n")
            for v in vertex_lines:
                obj_file.write(v)
            obj_file.write(f"# {num_vertices} vertices, 0 vertices normals\n\n")
            for f in face_lines:
                obj_file.write(f)
            obj_file.write(f"# {len(face_lines)} faces, 0 coords texture\n")

        geom_name = dae_file_path.split('/')[-1].replace('.dae', '')
        aabb_min, aabb_max = get_AABB_cvxhull(np.array(vertices))
        size = aabb_max-aabb_min
        translation = (aabb_max+aabb_min)/2.0
        collision_geoms[geom_name.lower()] = [
                   f'\t    <box size="{size[0]:.6f} {size[1]:.6f} {size[2]:.6f}"/> \n', translation]
        # "\t    <box>\n",
        # f"\t      <size>{size[0]:.6f} {size[1]:.6f} {size[2]:.6f}</size>\n",
        # "\t    </box>\n",
        # ]
        print(f"Conversion successful. OBJ file saved at {obj_file_path}")

    except Exception as e:
        print(f"Error during conversion: {e}")
    
# Example usage
convert_dae_to_obj('input_file.dae', 'output_file.obj')

path_gitfolder = os.path.dirname(os.path.abspath(__file__)) + "/.."
path_target = path_gitfolder+"/iris_environments/assets/mycobot_description/urdf/mycobot/mycobot_with_gripper_parallel.urdf"
package_name = "mycobot_description"
package_path = path_gitfolder+"/iris_environments/assets/mycobot_description"


def process_mesh_line(line):
    # Add your custom logic here

    print(f"Found mesh line: {line.strip()}")
    #get mesh path
    lineraw = line.strip()
    file_name = lineraw.split('"')[1]
    file_path = file_name.replace(f"package://{package_name}", package_path)
    file_path_obj = file_path.replace('.dae', '.obj')
    convert_dae_to_obj(file_path, file_path_obj)
    print(file_path)

def traverse_file_and_process(file_path):
    with open(file_path, 'r') as file:
        for line in file:
            if line.strip(' ').startswith('<mesh filename'):
                process_mesh_line(line)

traverse_file_and_process(path_target)


lines = []
current_link_name = None
all_lines = []
with open(path_target, 'r') as file:
    for l in file:
        if not l.strip().startswith('<!---'):
            all_lines.append(l)
    
for l in all_lines:
    do_append=True
    if '.dae"/>' in l:
        l = l.replace('.dae"/>', '.obj"/>') 
    if '<link name=' in l:
        current_link_name = l.replace('<link name="', '').replace('">', '').strip()
    if '<visual>' in l:
        l = l.replace('<visual>',f'<visual name="{current_link_name+"_visual"}">')
    if '<collision>' in l:
        l = l.replace('<collision>',f'<collision name="{current_link_name+"_collision"}">')
    if len(lines)>3 and '<collision' in lines[-2]:
        col_name = l.split('"')[1].split('/')[-1].replace('.obj', '')
        l_col_geom = collision_geoms[col_name.lower()][0]
        lines.append(l_col_geom)
        do_append = False
    if len(lines)>3 and '<collision' in lines[-4]:
        do_append = False
        trans = collision_geoms[col_name.lower()][1]
        original_trans = [float(s) for s in l.split('"')[1].replace('"', '').split(' ')[:3]]
        rpy = [float(s) for s in l.split("rpy")[1].split('"')[1].split(' ') if s != '']
        t = (rpy_to_matrix(np.array(rpy))@np.array(trans).reshape(-1,1)).squeeze()
        lines.append(f'\t<origin xyz = "{t[0]+original_trans[0]} {t[1]+original_trans[1]} {t[2]+original_trans[2]}" rpy' + l.split("rpy")[1])
        #lines.append(lines[-6])
    if do_append:
            lines.append(l)
    print(len(lines))
    
path = path_target.replace('.urdf', '') + "_obj.urdf"
with open(path, 'w') as file:
    for l in lines:
        file.write(l)
